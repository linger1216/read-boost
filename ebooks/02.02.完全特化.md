# 2.2 完全特化

闲话休提，咱直接说书，完全特化，没什么神奇，实际上模板也没什么神奇的，弄懂就好。

完全特化，实际上就是把模板参数给确定下来。

就那之前的例子来说：

    template<class T>
    T max(T a1, T a2)
    {
        return a1 < a2 ? a2 : a1;
    }

我们先特化一个int版本的来玩玩

    template<>
    int max(int a1, int a2)
    {
         return a1 < a2 ? a2 : a1;
    }

看，我们把模板T变成了int，这就是完全特化了，简单吧，刚才说的是**函数模板完全特化**，那么**类模板完全特化**呢？

让我们再看，假设有个类模板是这样的

    template<class T>
    class Compare
    {
    public:
        T max(T a1, T a2)
        {
             return a1 < a2 ? a2 : a1;
        }
    };
    
对应的类模板特化

    template<>
    class Compare<int>
    {
    public:
        int max(int a1, int a2)
        {
             return a1 < a2 ? a2 : a1;
        }
    };
    
好了，说完了。

别介啊，这位说了，完全特化我倒是弄明白了，但这东西有啥用呢？没事我特化一个int，一个char，一个double，有啥特殊意义呢？

听到这，我心下大变，惶恐不已，脑子CPU在急速狂转，对啊，干啥用的呢？但我面上却含笑不语，一副仙风道骨的模样，突然灵机一动，心中有了主意，不禁微微一笑，对他言道：“当然有用了，哈哈。”

“要知道，模板是针对一种普遍情况的，用行话来说就是泛型编程，但天道万千，不能事事都那么完美，记得杨过经常说，人生不如意，十有八九，所以我们这种普遍意义上的编程总有疏漏，对于这种疏漏，我们要用补丁的方式把它修复上去，这就是模板特化的意义。”

终于唬完了，我心中大定，面上不禁露出得意之色。

:)

“神棍，再说段吧，咱家还不是特别清楚，说不明白，抓回东厂喂狗”

我心中大恨，眼中透出紧迫之色，七舅姥爷哎，实在编不出来了，难道老子今天要归位？ 无奈赶紧求助现场观众，就当我快撑不住的时候，有个声音悠悠的再我耳边响起，**用户自定义对象**。

对啊，我怎么没想到，我抬头看了看各位看官，好像没人发出这个声音。

”别乱看，我用的传音入密，你不用慌张，看你小子说书还行，今日救你一命，快点说吧，小心那位爷不饶你“

我咳了咳，强作精神，列位，请看如下代码

    struct Node
    {
    	Node* next;
    	int data;
    };
    
    int main()
    {
    	Node node1;
    	node1.data = 1;
    	Node node2;
    	node2.data = 2;
    
    	Node max_node = max(node1,node2);
    	return 0;
    }

我定义了一个结构 **Node**，这种情况下，我编译肯定会出错,因为Node结构并没有定义operator < 动作，换句话说也就是编译器并不知道Node结构并不知道怎么比大小。

这时候我们可以为Node专门特化一个版本，比如

    template<>
    Node max(Node a1, Node a2)
    {
    	return a1.data < a2.data ? a2 : a1;
    }

这样就可以顺利编译了，如果以后有其他的自定义结构，我们还可以满足**开闭原则**呢，嘿嘿。


“嗯，嗯，咱家弄懂了，天色已晚，得嘞，回府。”

我心中暗道：“这个死太监，真难缠。”，突然想起来还没有拜谢那位看官，赶紧往台下看去，却没有听到任何声音，看来恩人早已离去。

我看看了窗外的远方，心想明天他还会来吧，突然远处飘过来一句话。


“别忘了，完全特化，其他流派中也叫显示特化。。。”

## links
  * [目录](<00.00.目录.md>)
  * 上一节: [术语规范](<02.01.术语规范.md>)
  * 下一节: [偏特化](<02.03.偏特化.md>)

