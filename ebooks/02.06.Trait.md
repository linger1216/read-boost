# 2.6 Trait

> trait

> 英 [treɪt; treɪ]  美 [tret]

> n. 特性，特点；品质；少许

> n. (Trait)人名；(法)特雷


各位看官，不好意思，今儿来晚了些，后堂跟大厨对付点事（Policy）小二楞着干嘛？快点给各位大爷续水，我呢今儿多说点，请各位多多海涵啊。

咱今儿说的是一位大人物，在STL，Boost界，那可是无人不知无人不晓，他年龄在五十多岁，头戴金翅相雕，身穿白缎子蟒袍，腰横玉带，大红中衣，怀抱象牙笏板，颌下花白胡须，此人正是typedef之父、掌朝太师、Trait。

我们今天就要说说当朝太师的事迹，说道这，哇的一声，茶馆甭管里外，全都嗡的一声，挤到前面，动都动不了，推车的，担担的，卖饭的，卖葱的，卖针的，卖线的，说书唱戏的，打把式卖艺的，耍猴的，卖大力丸的……都来了。

	template<typename T>
	struct Node
	{
		Node* next;
		T value;
	};

	int main()
	{
		Node<int> node;
		return 0;
	}

这是一个很普通的定义，根据T的类型来实例化具体的Node结构，比如

- Node<int>
- Node<char>

看起来是挺不错，但如果我们不小心给了如下类型，会发生什么？

	template<typename T>
	struct Node
	{
		Node* next;
		T value;
	};

	int main()
	{
		Node<int> node;
		Node<int*> node1;
		Node<int&> node2;
		return 0;
	}

node1还没啥，但node2就会编译出错。因为引用的同时必须要初始化的。

我们有没有办法让这段代码成功编译通过呢？

当然有的，那就是Trait的作用了。先看这个

	template<typename T>
	struct trait
	{
		typedef T value_type;
	};
	
代码很简单，只是将T的类型，重新typedef了一下，虽然很简单，但看官千万别小瞧了这行代码，这可是模板。模板可以干什么，模板是可以偏特化的，如

	template<typename T>
	struct trait<T*>
	{
		typedef T value_type;
	};

上面的意思是，如果T传入的时候是指针，我们还能把T typedef成value_type，换句话说，我们这时能区分T,和T*。
这就是其中奥妙，我们利用偏特化，从T中又萃取出了一个类型。

同样，我们也能萃取出引用类型

	template<typename T>
	struct trait<T&>
	{
		typedef T value_type;
	};

这时候我们只要修改一句代码，保证任何时候定义的变量都是原生变量T `typename trait<T>::value_type value;`

再看代码

	template<typename T>
	struct trait
	{
		typedef T value_type;
	};

	template<typename T>
	struct trait<T*>
	{
		typedef T value_type;
	};

	template<typename T>
	struct trait<T&>
	{
		typedef T value_type;
	};

	template<typename T>
	struct Node
	{
		Node* next;
		typename trait<T>::value_type value;
	};

	int main()
	{
		Node<int> node;
		Node<int*> node1;
		Node<int&> node2;
		return 0;
	}


编译成功，不管你怎么定义，我们能从int*，int&中正确的萃取正确的类型int，这就是trait的秘密。


看官，可能还不明白trait的厉害在哪，下面我来讲述下一场经典战役，还记得是60年前，太师当年年轻气盛，第一次出战，正走到山谷，就听山谷中“咚！咚！”炮声连天，伏兵四起，杀声震耳，满山遍野全是辽兵，各擎兵刃，如狼似虎。。。


