# 2.4 函数模板的偏特化

上回书说到，有个高人，指出偏特化是不能用于函数模板偏特化的，这件事情到底是不是真的呢？比如下列代码

    template<class T1, class T2>
    T1 f(T1 a, T2 b) 
    {
    	return a * b;
    }
    
    template<class T>
    T f<T, int> (T a, int b) 
    {
    	return a * b;
    }
    
    int main()
    {
    	f(33.3,34);
    	return 0;
    }

我们尝试来编译一下，结果如下

- g++： error: function template partial specialization ‘f<T, int>’ is not allowed
- vc++：error C2768: 'f' : illegal use of explicit template arguments

不得不承认，虽然C++很强大，但这是真的。

看官看到这里就要问了，如果函数模板缺少了这部分特性，
那使用函数模板不就会很杯具吗？
幸好，函数模板还有其它方法挽救，那就是**函数模板的重载**，可以达到类似于类模板偏特化的效果。

## 函数模板的重载

像上面的例子，我们只要修改下定义，像如下这样就可以通过编译了

    template<class T1, class T2>
    T1 f(T1 a, T2 b) 
    {
    	return a * b;
    }
    
    double f(double a, int b) 
    {
    	return a * b;
    }
    
    int main()
    {
    	f(33.3,34);
    	return 0;
    }

我刚把代码说出来，台下就一片闹哄哄，我一看情况不对，连忙说道：“老几位，老几位。。听我说句话：
鄙人知道大家要说什么，大家肯定要说，这算什么模板啊，这明显就是一个普通函数啊，虽然通过编译了，但这个函数完全就是打酱油的啊，我这一次需要double类型，你重载了一个函数。下次我使用char类型你岂不是还要重载一个函数，如果我特殊的情况很多，你这个方案就简直太坑爹啦。“

正如这样

    template<class T1, class T2>
    T1 f(T1 a, T2 b);
    
    double f(double a, int b) ;
    char f(char a, int b) ;
    Node f(Node a, int b) ;
    ...
    UserData f(UserData a, int b) ;

说完这番话，对大家抱拳作揖 ”我也没办法，这是衙门上头的规矩，我也破坏不了。”

大家一听是衙门的规矩，也只有摇摇头，哎，自古民不与官斗，认了吧。

我突然有个强烈的预感，那个高人又要说话了，果然，一个声音飘了过来，但这次不是传音入密，声音洪亮如钟，一番话说后，房梁嗡嗡作响。

“函数模板的偏特化，并不是技术上难以实现，而是当年衙门（C++标准委员会）的掌权人的一些人为原因造成，没有纳入标准，江湖能人才俊不能为我朝所用，凭的遗憾，但请大家不要失望，据我所知，不久的将来，衙门内会对这个案子重新讨论，到时候一定有个好的结果通知大家。”

说完这番话，茶馆里，老人小孩大姑娘小媳妇茶客店小二戏子，都兴奋的鼓掌，气氛一时高涨热烈。

嘿嘿，看我一番书，引起那么大的讨论，今天的赏钱一定可以多二两，我内心也偷笑了起来。


## links
  * [目录](<preface.md>)
  * 上一节: [偏特化](02.03.偏特化.md)
  * 下一节: [函数模板的偏特化](02.04.函数模板的偏特化.md)

