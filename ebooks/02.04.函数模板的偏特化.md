# 2.4 函数模板的偏特化

上回书说到，有个高人，指出偏特化是不能用于函数模板偏特化的，这件事情到底是不是真的呢？比如下列代码

    template<class T1, class T2>
    T1 f(T1 a, T2 b) 
    {
    	return a * b;
    }
    
    template<class T>
    T f<T, int> (T a, int b) 
    {
    	return a * b;
    }
    
    int main()
    {
    	f(33.3,34);
    	return 0;
    }


没错，虽然C++很强大，但不得不承认，这是真的。

看官看到这里就要问了 “这到底是为什么呢？” 

其实并不是技术上难以实现，只是C++标准委员会人为的原因造成，这个并没有纳入标准，但函数模板缺少了这部分特性，
岂不是很让人遗憾吗？ 幸好，函数模板还有其它方法挽救，那就是**函数模板的重载**，可以达到类似于类模板偏特化的效果。

## 函数模板的重载





严格的来说，函数模板并不支持偏特化，但由于可以对函数进行重载，所以可以达到类似于类模板偏特化的效果。
  template <class T> void f(T);  (a)
  根据重载规则，对（a）进行重载
  template < class T> void f(T*);  (b)
  如果将（a）称为基模板，那么（b）
  称为对基模板（a）的重载，而非对（a）的偏特化。C++的标准委员会仍在对下一个版本中是否允许函数模板的偏特化进行讨论。
